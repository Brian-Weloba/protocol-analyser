"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  default: () => index_default
});
module.exports = __toCommonJS(index_exports);
var import_elysia = require("elysia");
var import_prom_client = require("prom-client");
var DEFAULT_OPTIONS = {
  metricsPath: "/metrics",
  durationBuckets: [3e-3, 0.03, 0.1, 0.3, 1.5, 10],
  staticLabels: {},
  dynamicLabels: {},
  useRoutePath: true
};
var index_default = (userOptions = {}) => {
  const opts = { ...DEFAULT_OPTIONS, ...userOptions };
  const register = new import_prom_client.Registry();
  (0, import_prom_client.collectDefaultMetrics)({ register });
  const reservedLabels = /* @__PURE__ */ new Set(["method", "path", "status"]);
  const allLabels = { ...opts.staticLabels, ...opts.dynamicLabels };
  for (const label of Object.keys(allLabels)) {
    if (reservedLabels.has(label)) {
      throw new Error(`Label '${label}' is reserved`);
    }
  }
  const labelNames = [
    "method",
    "path",
    "status",
    ...Object.keys(opts.staticLabels),
    ...Object.keys(opts.dynamicLabels)
  ];
  const httpRequestCounter = new import_prom_client.Counter({
    name: "http_requests_total",
    help: "Total HTTP requests count",
    labelNames,
    registers: [register]
  });
  const httpRequestDuration = new import_prom_client.Histogram({
    name: "http_request_duration_seconds",
    help: "HTTP request duration in seconds",
    labelNames,
    buckets: opts.durationBuckets,
    registers: [register]
  });
  const getStatusCode = (ctx) => {
    if (typeof ctx.response === "object" && ctx.response !== null && "code" in ctx.response && typeof ctx.response.code === "number") {
      return ctx.response.code.toString();
    }
    if (ctx.set.status) {
      return ctx.set.status.toString() ?? "unknown";
    }
    return "500";
  };
  function getLabels(ctx) {
    const path = opts.useRoutePath ? ctx.route || ctx.path : ctx.path;
    const labels = {
      method: ctx.request.method,
      path: normalizePath(path),
      status: getStatusCode(ctx),
      ...opts.staticLabels
    };
    for (const [key, fn] of Object.entries(opts.dynamicLabels)) {
      labels[key] = fn(ctx);
    }
    return labels;
  }
  function normalizePath(path) {
    return path.replace(/\/\d+([\/?]|$)/g, "/:id$1");
  }
  return new import_elysia.Elysia({ name: "prometheus" }).derive({ as: "global" }, (ctx) => ({
    endTimer: httpRequestDuration.startTimer(getLabels(ctx))
  })).onAfterHandle({ as: "global" }, (ctx) => {
    if (ctx.path.endsWith(opts.metricsPath)) return;
    httpRequestCounter.inc(getLabels(ctx));
    ctx.endTimer(getLabels(ctx));
  }).onError({ as: "global" }, (ctx) => {
    if (!ctx.endTimer) return;
    if (ctx.path.endsWith(opts.metricsPath)) return;
    httpRequestCounter.inc(getLabels(ctx));
    ctx.endTimer(getLabels(ctx));
  }).get(opts.metricsPath, async () => {
    return new Response(await register.metrics(), {
      headers: { "Content-Type": register.contentType }
    });
  });
};
